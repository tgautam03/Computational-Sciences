I"Ie<h3 id="why-study-caches">Why study Caches?</h3>
<p>Let me first introduce a very simple problem of adding a scalar to each element of a 2D matrix. There are two ways in which I can do this:</p>
<ul>
  <li>Access elements row wise
    <div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">function</span><span class="nf"> rowAccess</span><span class="x">(</span><span class="n">A</span><span class="o">::</span><span class="kt">AbstractMatrix</span><span class="x">)</span>
      <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="x">(</span><span class="n">A</span><span class="x">)[</span><span class="mi">1</span><span class="x">]</span>
          <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="x">(</span><span class="n">A</span><span class="x">)[</span><span class="mi">2</span><span class="x">]</span>
              <span class="n">A</span><span class="x">[</span><span class="n">i</span><span class="x">,</span><span class="n">j</span><span class="x">]</span> <span class="o">=</span> <span class="n">A</span><span class="x">[</span><span class="n">i</span><span class="x">,</span><span class="n">j</span><span class="x">]</span><span class="o">+</span><span class="mi">1</span>
          <span class="k">end</span>
      <span class="k">end</span>
      <span class="k">return</span> <span class="n">A</span>
  <span class="k">end</span>
</code></pre></div>    </div>
  </li>
  <li>Access elements column wise
    <div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">function</span><span class="nf"> colAccess</span><span class="x">(</span><span class="n">A</span><span class="o">::</span><span class="kt">AbstractMatrix</span><span class="x">)</span>
      <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="x">(</span><span class="n">A</span><span class="x">)[</span><span class="mi">1</span><span class="x">]</span>
          <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="x">(</span><span class="n">A</span><span class="x">)[</span><span class="mi">2</span><span class="x">]</span>
              <span class="n">A</span><span class="x">[</span><span class="n">j</span><span class="x">,</span><span class="n">i</span><span class="x">]</span> <span class="o">=</span> <span class="n">A</span><span class="x">[</span><span class="n">j</span><span class="x">,</span><span class="n">i</span><span class="x">]</span><span class="o">+</span><span class="mi">1</span>
          <span class="k">end</span>
      <span class="k">end</span>
      <span class="k">return</span> <span class="n">A</span>
  <span class="k">end</span>
</code></pre></div>    </div>
    <blockquote>
      <p>I’ll be using Julia Programming language but feel free to follow along with any programming language.</p>
    </blockquote>
  </li>
</ul>

<p>When I run both of these independently (supplying \(5000\times5000\) matrix <code class="language-plaintext highlighter-rouge">A</code>) and benchmark it, I observe that the function <code class="language-plaintext highlighter-rouge">rowAccess</code> takes 160.2 ms to run while <code class="language-plaintext highlighter-rouge">colAccess</code> finishes in 16.4 ms!!</p>
<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@btime</span> <span class="n">_</span> <span class="o">=</span> <span class="n">colAccess</span><span class="x">(</span><span class="n">A</span><span class="x">);</span>
<span class="mf">16.400</span> <span class="n">ms</span> <span class="x">(</span><span class="mi">0</span> <span class="n">allocations</span><span class="o">:</span> <span class="mi">0</span> <span class="n">bytes</span><span class="x">)</span>
</code></pre></div></div>
<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@btime</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rowAccess</span><span class="x">(</span><span class="n">A</span><span class="x">);</span>
<span class="mf">160.207</span> <span class="n">ms</span> <span class="x">(</span><span class="mi">0</span> <span class="n">allocations</span><span class="o">:</span> <span class="mi">0</span> <span class="n">bytes</span><span class="x">)</span>
</code></pre></div></div>
<p>Both of these results can be explained easily after a good understanding of <strong>Caches</strong>, hence it’s imperative that every programmer must understand how memories work in modern computers. In this blog post, I’ll be explaining the basic concepts related to <strong>Memory Heirarchy</strong>, so that you can start writing <em>cache friendly</em> code and avoid mistakes such the one in function <code class="language-plaintext highlighter-rouge">rowAccess</code>.</p>
<blockquote>
  <p>If you try to do the same thing in C/C++, you’ll notice that row access runs faster than column access. Don’t worry, this is normal and by the end of this post you’ll have the answer to this as well.</p>
</blockquote>

<h3 id="introduction">Introduction</h3>
<p>For most of the basic programming tasks, a simple model of a computer system is assumed in which CPU executes instructions and a memory system holds data/instructions for the CPU. This memory is assumed to be a linear array of bytes, where each memory location can be accessed in constant amount of time.</p>

<p><strong>In practice, a <em>memory system</em> is a hierarchy of storage devices with different capacities, costs and access times.</strong></p>

<div class="imgcap">
<img src="/assets/01_Caches/fig01.png" />
<div class="thecap">Caches, Registers and RAM are the main storage devices in a modern computer.</div>
</div>

<p>From the figure above you can see different types of storage devices:</p>
<ul>
  <li><strong>Registers</strong>: Very small in size (few KBs), very fast access times, very expensive.</li>
  <li><strong>Caches</strong>: Small in size (100s of KBs to few MBs), fast access times, expensive.</li>
  <li><strong>RAM</strong>: Large in size (few GBs), moderate access times, moderate cost.</li>
</ul>

<blockquote>
  <p>Access time is the time required to move data to the ALU for processing.</p>
</blockquote>

<p>Let’s now see in detail how these memories work by going through the code example line by line.</p>

<blockquote>
  <p>I’ll be discussing the details in a very abstract manner where I’ll not be diving into the bit-wise representation of arrays. So just remember that the way data is stores in RAM or cache is a bit more complicated than what I’ll be discussing. However I’ll cover these minute details in some other blog post.</p>
</blockquote>

<h3 id="random-access-memory-ram">Random Access Memory (RAM)</h3>
<p><strong>The most important thing to remember is that the data is stored in RAM in a linear fashion (1D).</strong></p>

<p>The first step is to generate a \(5000\times5000\) matrix of random numbers. This is done in Julia as follows:</p>
<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="mi">5000</span><span class="x">,</span> <span class="mi">5000</span><span class="x">)</span><span class="o">*</span><span class="mi">10</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5000×5000 Matrix{Float64}:
 5.03846   4.58912   7.1005    5.21892   …  4.54396   7.36507   4.01988
 2.17532   2.41624   8.64615   0.84582      2.4431    2.97512   4.40888
 1.93575   0.699285  8.7284    4.6449       1.37964   6.23566   2.98806
 3.83268   8.42017   9.66205   7.14073      7.75752   0.183603  9.57737
 4.6633    2.64513   8.15831   5.45722      8.30875   2.57161   0.02877
 8.80673   2.21542   8.13674   9.93325   …  7.81374   7.65582   8.46948
 7.67453   5.43839   1.6908    8.41406      0.425791  5.46946   8.81717
 1.96266   4.69834   6.08504   2.73894      2.37154   2.1411    2.39905
 0.744606  3.93134   2.12461   1.30628      0.160766  4.52978   9.93005
 9.5532    3.50446   5.16795   0.891007     1.05626   4.37425   2.84276
 9.15744   6.42421   7.94237   1.89686   …  6.61071   9.65093   7.54344
 4.50209   5.50591   8.60566   1.73348      8.66581   5.33027   2.9608
 1.44016   2.79131   9.62346   7.55472      6.54422   4.33858   9.03697
 ⋮                                       ⋱                      
 5.73005   0.437692  7.03775   5.63305      5.82807   8.73      0.56327
 2.08363   1.23326   5.05221   3.87795      7.64193   5.70619   0.6294
 9.12929   1.17639   9.60084   3.89799   …  6.52743   4.21519   5.92673
 9.35454   6.00617   5.482     9.12613      0.689471  6.18523   6.24744
 4.90895   1.52338   9.34416   7.82992      3.30676   2.2884    5.95591
 1.27204   2.50706   6.54941   3.55047      5.87974   7.33108   5.27113
 3.73647   2.37662   2.22628   4.7821       4.95708   3.00419   4.84946
 6.98472   2.7361    3.44572   3.36757   …  6.0354    9.19172   9.32838
 4.70179   6.49456   0.326857  2.93387      8.12008   2.41638   5.09379
 5.25246   0.102174  5.58784   9.64384      3.47783   9.39589   2.15167
 1.78689   9.9175    3.11802   3.51899      5.82515   0.55363  8.6704
 9.34795   6.2792    0.262552  9.31061      5.51025   9.08796   0.06783
</code></pre></div></div>

<p>Julia stores this matrix in a column major way, i.e. all elements of column 1 is stored first followed by column 2, 3 and so on.</p>

<div class="imgcap">
<img src="/assets/01_Caches/fig02.png" />
<div class="thecap">Data is stored in linear fashion in a RAM. Julia uses column major format but languages like C/C++ and python numpy stores in row major format.</div>
</div>

<p>The next thing we do is go into the functions and execute the code line by line.</p>

<h3 id="registers">Registers</h3>
<p>In both functions (<code class="language-plaintext highlighter-rouge">colAccess</code> and <code class="language-plaintext highlighter-rouge">rowAccess</code>), the first two lines are same</p>
<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="x">(</span><span class="n">A</span><span class="x">)[</span><span class="mi">1</span><span class="x">]</span>
	<span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">size</span><span class="x">(</span><span class="n">A</span><span class="x">)[</span><span class="mi">2</span><span class="x">]</span>
</code></pre></div></div>
<p>When these lines are executed, value of variables <code class="language-plaintext highlighter-rouge">i</code>, <code class="language-plaintext highlighter-rouge">j</code>, <code class="language-plaintext highlighter-rouge">size(A)[1]</code> and <code class="language-plaintext highlighter-rouge">size(A)[2]</code> are stored in registers. This is done so that these small values (which are used repeatedly) are stored close to the ALU, hence decreasing the access times.</p>

<blockquote>
  <p>Access time of a register (time to move data from register to ALU) is negligible hence for programming purposes, it can be considered as 0 clock cycles (atleast relative to RAM).</p>
</blockquote>

<p>Next, <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> are used to access the element of the matrix. This is where things get interesting.</p>

<h3 id="caches">Caches</h3>
<p>For an instant let’s assume that there’s no cache in between the register and RAM, and we try to access data directly from RAM. When <code class="language-plaintext highlighter-rouge">A[j,i] = A[j,i]+1</code> is executed for <code class="language-plaintext highlighter-rouge">i,j=1</code>, element <code class="language-plaintext highlighter-rouge">A[1][1]</code> is fetched from the RAM memory locaion 0 and passed to the ALU where 1 is added to it and it’s deposited back to the RAM location it was fetched from. The same thing then happens for <code class="language-plaintext highlighter-rouge">A[2][1]</code> followed by <code class="language-plaintext highlighter-rouge">A[3][1]</code>, <code class="language-plaintext highlighter-rouge">A[4][1]</code>, and so on. Now the problem with this is that fetching data from RAM is slow (15-100 clock cycles), and to fetch \(5000\times5000\) elements, it’ll take forever (atleast in terms of clock cycles). We can’t use registers to store these values because it’s too small and it already contains CPU instructions and some small constants. To get around this problem, a fast memory called <strong>cache</strong> is put inside the CPU chip (closer to ALU) which can hold some data for fast accesses. The size of a cache is really small as compared to RAM and can store just a few elements (e.g. RAM on my laptop is 16GB but my i7 CPU has only 9MB of cache).</p>

<blockquote>
  <p>It’s quite logical to think, why not increase the size of a register? The simple answer to this is cost. Registers are very expensive to make and increasing it’s size will make the CPU super expensive (not to mention the physical size will increase too). 
Note: The same logic goes for cache memories as well.</p>
</blockquote>

<p>In order to understand how caches manage data, a look into the structure of cache is important.</p>

<h4 id="general-structure-of-cache-memory">General Structure of Cache Memory</h4>
<p>A cache is a <strong>hardware managed memory</strong> made up of several <em>sets</em> (or lines), which can hold data in a linear fashion.</p>

<div class="imgcap">
<img src="/assets/01_Caches/fig03.png" />
<div class="thecap">Note that the data can be placed only in a specific portion of each cache line. I'll explain how the left out storage in each line is used in another blog post.</div>
</div>

<p>When a data is moved from RAM to a cache line, it’s moved in <strong>blocks</strong>. Let me illustrate this using the code example.
Suppose our cache has 5 lines where each line can hold 4 floating point (64 bit) values. So when the program tries to access  <code class="language-plaintext highlighter-rouge">A[1][1]</code>, the block containing elements <code class="language-plaintext highlighter-rouge">[A[1][1],A[2][1],A[3][1],A[4][1]]</code> is moved to the 1st cache line in single go and then required element is fed to ALU from there. The size of this <em>block</em> is decided by the amount a cache line can hold. This is known as <strong>Block Size (B)</strong>.</p>

<div class="imgcap">
<img src="/assets/01_Caches/fig04.png" />
<div class="thecap"></div>
</div>

<p>Now in the next iteration when <code class="language-plaintext highlighter-rouge">i=2,j=1</code>, element <code class="language-plaintext highlighter-rouge">A[2][1]</code> is already in cache so it can be accessed very quickly. Same goes for elements <code class="language-plaintext highlighter-rouge">A[3][1]</code> and <code class="language-plaintext highlighter-rouge">A[4][1]</code>, but when <code class="language-plaintext highlighter-rouge">A[5][1]</code> is required, block containing <code class="language-plaintext highlighter-rouge">[A[5][1],A[6][1],A[7][1],A[8][1]]</code> is moved to the 2nd cache line in one go, and so on. This solves the problem of slow data accesses from RAM but relies on programmers ability to use <strong>Data Locality</strong>, i.e. after accessing say <code class="language-plaintext highlighter-rouge">A[1][1]</code> it’s programmers responsibility to either reuse <code class="language-plaintext highlighter-rouge">A[1][1]</code> or access <code class="language-plaintext highlighter-rouge">A[2][1]</code>.</p>
<blockquote>
  <p>When all cache lines are full, eliminations happen where older elements are removed first. For example <code class="language-plaintext highlighter-rouge">[A[21][1],A[22][1],A[23][1],A[24][1]]</code> will be put in cache line 1.</p>
</blockquote>

<blockquote>
  <p>Note that the movement of data in blocks is hardware managed hence it’s super efficient. So we only have to incur a time penalty for the movement of 1st element but following elements can be accessed quickly.</p>
</blockquote>

<h1 id="analysing-rowaccess-vs-colaccess">Analysing <code class="language-plaintext highlighter-rouge">rowAccess</code> vs <code class="language-plaintext highlighter-rouge">colAccess</code></h1>
<p>Let’s now compare the two implementations in detail. For simplicity, I’ll be doing hand simulation of first 6 iterations of both fuctions, but this happens for all other iterations. Also let’s assume it takes 1 clock cycle to fetch data from cache and 50 clock cycles to fetch data from RAM.</p>
<ul>
  <li>Iteration 1 (<code class="language-plaintext highlighter-rouge">i=1,j=1</code>):
    <ul>
      <li>No <code class="language-plaintext highlighter-rouge">A[1][1]</code> in cache so elements <code class="language-plaintext highlighter-rouge">[A[1][1],A[2][1],A[3][1],A[4][1]]</code> are placed in cache.</li>
      <li><code class="language-plaintext highlighter-rouge">colAccess</code> time: 50 clock cycles.</li>
      <li><code class="language-plaintext highlighter-rouge">rowAccess</code> time: 50 clock cycles.</li>
    </ul>
  </li>
  <li>Iteration 2 (<code class="language-plaintext highlighter-rouge">i=i,j=2</code>):
    <ul>
      <li><code class="language-plaintext highlighter-rouge">colAccess</code> time: 1 clock cycle as <code class="language-plaintext highlighter-rouge">A[2][1]</code> is found in cache. Here’s how cache will look like for this function.</li>
    </ul>
    <div class="imgcap">
  <img src="/assets/01_Caches/fig04.png" />
  <div class="thecap"></div>
  </div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">rowAccess</code> time: 50 clock cycles as <code class="language-plaintext highlighter-rouge">A[1][2]</code> is not found in cache. However the whole block will be placed in cache.</li>
    </ul>
    <div class="imgcap">
  <img src="/assets/01_Caches/fig06.png" />
  <div class="thecap"></div>
  </div>
    <blockquote>
      <p>I’m considering <em>Fully Associative Cache</em>. Don’t worry, I’ll cover different types of <strong>Cache Mappings</strong> in another blog.</p>
    </blockquote>
  </li>
  <li>Iteration 3 (<code class="language-plaintext highlighter-rouge">i=i,j=3</code>):
    <ul>
      <li><code class="language-plaintext highlighter-rouge">colAccess</code> time: 1 clock cycle as <code class="language-plaintext highlighter-rouge">A[3][1]</code> is found in cache. Here’s how cache will look like for this function.</li>
    </ul>
    <div class="imgcap">
  <img src="/assets/01_Caches/fig04.png" />
  <div class="thecap"></div>
  </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">rowAccess</code> time: 50 clock cycles as <code class="language-plaintext highlighter-rouge">A[1][3]</code> is not found in cache. However the whole block will be placed again in cache.</li>
    </ul>
    <div class="imgcap">
  <img src="/assets/01_Caches/fig07.png" />
  <div class="thecap"></div>
  </div>
  </li>
  <li>Iteration 4 (<code class="language-plaintext highlighter-rouge">i=i,j=4</code>):
    <ul>
      <li><code class="language-plaintext highlighter-rouge">colAccess</code> time: 1 clock cycle as <code class="language-plaintext highlighter-rouge">A[4][1]</code> is found in cache. Here’s how cache will look like for this function.</li>
    </ul>
    <div class="imgcap">
  <img src="/assets/01_Caches/fig04.png" />
  <div class="thecap"></div>
  </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">rowAccess</code> time: 50 clock cycles as <code class="language-plaintext highlighter-rouge">A[1][4]</code> is not found in cache. However the whole block will be placed again in cache.</li>
    </ul>
    <div class="imgcap">
  <img src="/assets/01_Caches/fig08.png" />
  <div class="thecap"></div>
  </div>
  </li>
  <li>Iteration 5 (<code class="language-plaintext highlighter-rouge">i=i,j=5</code>):
    <ul>
      <li><code class="language-plaintext highlighter-rouge">colAccess</code> time: 50 clock cycles as <code class="language-plaintext highlighter-rouge">A[5][1]</code> is not found in cache. Here’s how cache will look like for this function.</li>
    </ul>
    <div class="imgcap">
  <img src="/assets/01_Caches/fig05.png" />
  <div class="thecap"></div>
  </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">rowAccess</code> time: 50 clock cycles as <code class="language-plaintext highlighter-rouge">A[1][5]</code> is not found in cache. However the whole block will be placed again in cache.</li>
    </ul>
    <div class="imgcap">
  <img src="/assets/01_Caches/fig10.png" />
  <div class="thecap"></div>
  </div>
  </li>
  <li>Iteration 6 (<code class="language-plaintext highlighter-rouge">i=i,j=6</code>):
    <ul>
      <li><code class="language-plaintext highlighter-rouge">colAccess</code> time: 1 clock cycle as <code class="language-plaintext highlighter-rouge">A[6][1]</code> is found in cache. Here’s how cache will look like for this function.</li>
    </ul>
    <div class="imgcap">
  <img src="/assets/01_Caches/fig09.png" />
  <div class="thecap"></div>
  </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">rowAccess</code> time: 50 clock cycles as <code class="language-plaintext highlighter-rouge">A[1][6]</code> is not found in cache. However the whole block will be placed again in cache after eliminating the data from line 1.</li>
    </ul>
    <div class="imgcap">
  <img src="/assets/01_Caches/fig10.png" />
  <div class="thecap"></div>
  </div>
  </li>
</ul>

<p>This goes on and on for all the elements and at the end, <code class="language-plaintext highlighter-rouge">colAccess</code> will have far fewer <em>cache misses</em> and will run efficiently.</p>

<blockquote>
  <p>Notice how eliminations are crucial to this. If our matrix was say \(5\times5\), both implementations will be equally efficient.</p>
  <div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">A</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="mi">5</span><span class="x">,</span> <span class="mi">5</span><span class="x">)</span><span class="o">*</span><span class="mi">10</span>
<span class="mi">5</span><span class="n">×5</span> <span class="kt">Matrix</span><span class="x">{</span><span class="kt">Float64</span><span class="x">}</span><span class="o">:</span>
<span class="mf">2.28675</span>  <span class="mf">0.992201</span>  <span class="mf">2.73413</span>  <span class="mf">0.721498</span>  <span class="mf">8.47404</span>
<span class="mf">0.40424</span>  <span class="mf">8.14012</span>   <span class="mf">7.4764</span>   <span class="mf">7.52936</span>   <span class="mf">3.13966</span>
<span class="mf">8.38979</span>  <span class="mf">7.98449</span>   <span class="mf">9.05752</span>  <span class="mf">1.56374</span>   <span class="mf">5.53432</span>
<span class="mf">8.06838</span>  <span class="mf">3.65573</span>   <span class="mf">8.05323</span>  <span class="mf">4.22322</span>   <span class="mf">7.1832</span>
<span class="mf">8.04449</span>  <span class="mf">3.40892</span>   <span class="mf">4.79235</span>  <span class="mf">4.87289</span>   <span class="mf">1.25914</span>
</code></pre></div>  </div>
  <div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@btime</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rowAccess</span><span class="x">(</span><span class="n">A</span><span class="x">);</span>
<span class="mf">25.951</span> <span class="n">ns</span> <span class="x">(</span><span class="mi">0</span> <span class="n">allocations</span><span class="o">:</span> <span class="mi">0</span> <span class="n">bytes</span><span class="x">)</span>
</code></pre></div>  </div>
  <div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@btime</span> <span class="n">_</span> <span class="o">=</span> <span class="n">colAccess</span><span class="x">(</span><span class="n">A</span><span class="x">);</span>
<span class="mf">23.059</span> <span class="n">ns</span> <span class="x">(</span><span class="mi">0</span> <span class="n">allocations</span><span class="o">:</span> <span class="mi">0</span> <span class="n">bytes</span><span class="x">)</span>
</code></pre></div>  </div>
  <p>See how the runtime is almost the same for both now.</p>
</blockquote>

<h3 id="conclusion">Conclusion</h3>
<p>This post covers:</p>
<ul>
  <li>Basics of memory hierarchy of modern computers.</li>
  <li>Movement of data inbetween RAM and Cache.</li>
  <li>Basic workings of Cache.</li>
</ul>

<h3 id="useful-links">Useful Links</h3>
<ul>
  <li>Programming Language: <a href="https://julialang.org/">Julia Programming Language</a></li>
  <li>Example Code: <a href="https://github.com/tgautam03/tgautam03.github.io/blob/master/assets/01_Caches/Cache%20Misses.ipynb">jupyter notebook</a></li>
</ul>
:ET